<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä ‚Äî Live Canvas</title>
    <style>
      :root { --bg:#000000; --panel:#0a0a0a; --panel-2:#0f0f0f; --border:#1a1a1a; --text:#e6edf3; --muted:#9aa7b6; --accent:#60a5fa; --shadow:0 8px 28px rgba(0,0,0,0.6); }
      body { margin: 0; font-family: system-ui, Arial, sans-serif; display: grid; grid-template-columns: 300px 1fr; grid-template-areas: 'sidebar stage'; height: 100vh; background: #000; color: var(--text); }
      /* 7TV panel styles */
      .st-panel { border: 1px solid var(--border); background: var(--panel-2); border-radius: 8px; padding: 10px; }
      .st-panel header { display:flex; align-items:center; justify-content: space-between; gap:8px; margin-bottom:8px; }
      .st-panel header .ttl { display:flex; align-items:center; gap:8px; font-weight:700; }
      .st-panel input[type="text"] { width: 100%; background:#111; color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 10px; }
      .st-row { display:flex; gap:8px; align-items:center; }
      .st-saved { display:flex; flex-direction: column; gap:6px; max-height: 120px; overflow-y:auto; overflow-x:hidden; padding-bottom:4px; }
      .st-chip { display:flex; align-items:center; justify-content: space-between; gap:6px; background:#0f0f0f; border:1px solid var(--border); color:var(--text); border-radius:999px; padding:4px 8px; white-space:nowrap; cursor:pointer; width: 100%; box-sizing: border-box; }
      .st-chip .del { background:transparent; border:none; color:#9aa7b6; cursor:pointer; }
      .st-chip:hover { border-color:#2a3a55; }
      #emoteGrid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 6px; margin-top: 8px; max-height: 260px; overflow-y: auto; overflow-x: hidden; }
      #emoteGrid .emote { width: 44px; height: 44px; display:flex; align-items:center; justify-content:center; background:#0f0f0f; border:1px solid var(--border); border-radius:6px; overflow:hidden; }
      #emoteGrid img { max-width: 100%; max-height: 100%; display:block; }
      /* Pretty, fading scrollbars */
      .scroll-fade { scrollbar-width: thin; scrollbar-color: transparent transparent; }
      .scroll-fade:hover { scrollbar-color: rgba(96,165,250,0.6) transparent; }
      .scroll-fade::-webkit-scrollbar { width: 8px; height: 8px; background: transparent; }
      .scroll-fade::-webkit-scrollbar-thumb { background: transparent; border-radius: 8px; }
      .scroll-fade:hover::-webkit-scrollbar-thumb { background: rgba(96,165,250,0.5); }
      .scroll-fade::-webkit-scrollbar-corner { background: transparent; }
      .toolbar { grid-area: sidebar; border-right: 1px solid var(--border); padding: 12px; display: flex; flex-direction: column; gap: 10px; background: #000; min-height: 0; overflow-y: auto; overflow-x: hidden; }
      .toolbar section { border: 1px solid var(--border); background: var(--panel-2); border-radius: 8px; padding: 10px; }
      .toolbar h3 { margin: 0 0 8px 0; font-size: 14px; color: var(--text); }
      .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      #stageWrap { grid-area: stage; position: relative; background: #000; min-width:0; border: 1px solid var(--border); box-shadow: 0 0 0 3px rgba(0,0,0,0.6) inset; border-radius: 8px; }
      #stage { background: #000000; display: block; width: 100%; height: 100%; }
      .overlay-item { position: absolute; cursor: move; }
      
      .overlay-box { position: absolute; box-sizing: border-box; border: 1px dashed rgba(255,255,255,0.25); }
      .overlay-box:hover { border-color: rgba(96,165,250,0.6); }
      .resize { position: absolute; right: -6px; bottom: -6px; width: 14px; height: 14px; background: rgba(96,165,250,0.9); border: 1px solid #1a1a1a; border-radius: 3px; cursor: nwse-resize; }
      .close { position:absolute; right:-6px; top:-6px; width:18px; height:18px; border:none; border-radius:50%; background:#000000aa; color:#fff; font-size:12px; line-height:18px; text-align:center; cursor:pointer; }
      .thumb { max-width: 100%; }
      button, input[type="color"], input[type="range"], select { cursor: pointer; }
      button, select { background: #111; color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 6px 10px; }
      /* File input button to black */
      input[type="file"] { color: var(--text); }
      input[type="file"]::file-selector-button { background:#111; color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 10px; cursor:pointer; }
      input[type="file"]::-webkit-file-upload-button { background:#111; color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 10px; cursor:pointer; }
      input[type="range"] { accent-color: var(--accent); }
      .hint { font-size: 12px; color: var(--muted); }
      /* Catalog (docked in sidebar bottom) */
      #catalog { margin-top: auto; width: 100%; max-height: 40vh; overflow: auto; background: rgba(10,10,10,0.9); backdrop-filter: blur(3px); border: 1px solid var(--border); border-radius: 8px; box-shadow: var(--shadow); }
      #catalog header { display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; border-bottom: 1px solid var(--border); font-size: 13px; font-weight: 600; color: var(--text); }
      #catalog .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; padding: 10px; }
      #catalog .cell { position: relative; width: 100%; aspect-ratio: 1 / 1; border: 1px solid var(--border); border-radius: 6px; overflow: hidden; background: #0f1622; }
      #catalog .cell img, #catalog .cell video { width: 100%; height: 100%; object-fit: cover; display: block; }
      #catalog .cell button.del { position: absolute; right: 4px; top: 4px; border: none; background: #000000aa; color: #fff; width: 18px; height: 18px; border-radius: 50%; font-size: 12px; cursor: pointer; }
      #catalog .drop { padding: 8px 10px; border-top: 1px dashed #324054; color: var(--muted); font-size: 12px; }
      #catalog.drop-active { outline: 2px dashed var(--accent); outline-offset: 2px; }
      #stageWrap.stage-drop { outline: 2px dashed var(--accent); outline-offset: -2px; }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <section class="st-panel">
        <header>
          <div class="ttl">7TV Emotes</div>
        </header>
        <div class="st-row" style="margin-bottom:6px;">
          <input id="stSetId" type="text" placeholder="Emote Set ID" />
          <button id="stLoad">–î–æ–±–∞–≤–∏—Ç—å —Å–µ—Ç</button>
        </div>
        <div class="st-saved" id="stSaved"></div>
        <div class="st-row">
          <input id="stSearch" type="text" placeholder="–ü–æ–∏—Å–∫ –ø–æ —ç–º–æ—Ç–∞–º" />
        </div>
        <div id="emoteGrid" class="scroll-fade"></div>
      </section>
      <section>
        <h3>–ö–∏—Å—Ç—å</h3>
        <div class="row">
          <label>–¶–≤–µ—Ç <input id="brushColor" type="color" value="#ff0000" /></label>
          <label>–¢–æ–ª—â–∏–Ω–∞ <input id="brushSize" type="range" min="1" max="40" value="6" /></label>
        </div>
        <div class="row">
          <button id="toolBrush">–ö–∏—Å—Ç—å</button>
          <button id="toolErase">–õ–∞—Å—Ç–∏–∫</button>
          <button id="clearCanvas">–û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>
        <div class="hint">–õ–ö–ú ‚Äî —Ä–∏—Å–æ–≤–∞—Ç—å, Shift+–õ–ö–ú ‚Äî –ø—Ä—è–º–∞—è –ª–∏–Ω–∏—è</div>
      </section>

      <section>
        <h3>–ú–µ–¥–∏–∞</h3>
        <div class="row">
          <input id="fileInput" type="file" accept="image/png,image/gif,video/mp4" />
        </div>
        <div class="row">
          <button id="addUrlBtn">–î–æ–±–∞–≤–∏—Ç—å –ø–æ URL</button>
        </div>
      </section>

      

      

      <section>
        <h3>–°—Ü–µ–Ω–∞</h3>
        <div class="row">
          <label>–†–∞–∑–º–µ—Ä: 
            <select id="presetSize">
              <option value="1280x720">1280x720</option>
              <option value="1920x1080" selected>1920x1080</option>
              <option value="2560x1440">2560x1440</option>
            </select>
          </label>
        </div>
        <div class="row">
          <button id="sendState">–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ</button>
        </div>
        <div class="hint">–í—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏</div>
      </section>

      <div id="catalog">
        <header>
          <span>–ö–∞—Ç–∞–ª–æ–≥ –º–µ–¥–∏–∞</span>
          <button id="clearCatalog" title="–û—á–∏—Å—Ç–∏—Ç—å –∫–∞—Ç–∞–ª–æ–≥">üóë</button>
        </header>
        <div class="grid" id="catalogGrid"></div>
        <div class="drop">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ PNG/GIF/MP4 –∏–ª–∏ —Å—Å—ã–ª–∫—É (YouTube/–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ)</div>
      </div>
    </div>

    <div id="stageWrap">
      <canvas id="stage"></canvas>
      
    </div>

    <script>
      const serverUrl = (location.hostname === 'localhost' || location.hostname === '127.0.0.1')
        ? 'http://localhost:3001'
        : location.origin;

      const stage = document.getElementById('stage');
      const wrap = document.getElementById('stageWrap');
      const ctx = stage.getContext('2d');
      const brushColor = document.getElementById('brushColor');
      const brushSize = document.getElementById('brushSize');
      const toolBrush = document.getElementById('toolBrush');
      const toolErase = document.getElementById('toolErase');
      const clearCanvasBtn = document.getElementById('clearCanvas');
      const fileInput = document.getElementById('fileInput');
      const presetSize = document.getElementById('presetSize');
      const sendStateBtn = document.getElementById('sendState');
      const stSetId = document.getElementById('stSetId');
      const stLoadBtn = document.getElementById('stLoad');
      const stSearch = document.getElementById('stSearch');
      const emoteGrid = document.getElementById('emoteGrid');
      const stSaved = document.getElementById('stSaved');
      

      let tool = 'brush';
      let drawing = false;
      let lastPoint = null;
      let mediaItems = []; // { id, type:'image'|'video', src, x,y,w,h }
      const CATALOG_KEY = 'mediaCatalogV1';
      let catalog = [];
      let emoteList = [];
      let emoteFilter = '';
      const ST_SAVED_KEY = 'stSavedSetsV1';
      let savedSets = [];
      

      function setCanvasSize(w, h) {
        stage.width = w; stage.height = h;
        wrap.style.width = w + 'px';
        wrap.style.height = h + 'px';
        stage.style.width = '100%';
        stage.style.height = '100%';
        render();
        broadcastState();
        
      }

      function parseSize(v) { const [w,h]=v.split('x').map(Number); return {w,h}; }
      const { w: initW, h: initH } = parseSize(presetSize.value);
      setCanvasSize(initW, initH);

      presetSize.addEventListener('change', () => {
        const { w, h } = parseSize(presetSize.value);
        setCanvasSize(w, h);
      });

      toolBrush.onclick = () => tool = 'brush';
      toolErase.onclick = () => tool = 'erase';
      clearCanvasBtn.onclick = () => { ctx.clearRect(0,0,stage.width, stage.height); render(); broadcastState(); };

      stage.addEventListener('mousedown', (e) => { drawing = true; lastPoint = getPos(e); });
      stage.addEventListener('mouseup', () => { drawing = false; lastPoint = null; broadcastState(); });
      stage.addEventListener('mouseleave', () => { drawing = false; lastPoint = null; });
      stage.addEventListener('mousemove', (e) => {
        if (!drawing) return;
        const p = getPos(e);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = Number(brushSize.value);
        if (tool === 'erase') { ctx.globalCompositeOperation = 'destination-out'; ctx.strokeStyle = 'rgba(0,0,0,1)'; }
        else { ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = brushColor.value; }
        ctx.beginPath();
        const from = e.shiftKey && lastPoint ? lastPoint : getPos(e);
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
        lastPoint = p;
      });

      function getPos(e) {
        const rect = stage.getBoundingClientRect();
        return { x: (e.clientX - rect.left) * (stage.width / rect.width), y: (e.clientY - rect.top) * (stage.height / rect.height) };
      }

      // Media handling
      fileInput.addEventListener('change', async () => {
        const file = fileInput.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const isVideo = file.type.includes('video');
        addMedia(url, isVideo ? 'video' : 'image');
        fileInput.value = '';
      });

      document.getElementById('addUrlBtn').onclick = () => {
        const url = prompt('URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (png/gif), –≤–∏–¥–µ–æ (mp4) –∏–ª–∏ YouTube:');
        if (!url) return;
        const ytId = parseYouTube(url);
        if (ytId) {
          const embed = ytToEmbed(ytId);
          addMedia(embed, 'youtube');
          addToCatalog(embed, 'youtube');
          return;
        }
        const type = url.endsWith('.mp4') ? 'video' : 'image';
        addMedia(url, type);
        addToCatalog(url, type);
      };

      

      // 7TV: load emote set by ID
      stLoadBtn.onclick = async () => {
        const id = (stSetId.value || '').trim();
        if (!id) return;
        try {
          const res = await fetch(`https://7tv.io/v3/emote-sets/${id}`);
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const data = await res.json();
          emoteList = (data.emotes || []).map(e => ({
            id: e.id || (e.data && e.data.id),
            name: e.name || (e.data && e.data.name),
            host: (e.data && e.data.host) || e.host
          }));
          const setName = data.name || (data.owner && data.owner.display_name) || id;
          addSavedSet({ id, name: setName });
          renderEmotes();
        } catch (err) {
          console.warn('7TV load failed', err);
          emoteList = [];
          renderEmotes();
        }
      };

      stSearch.addEventListener('input', () => { emoteFilter = stSearch.value.toLowerCase(); renderEmotes(); });

      function pickEmoteUrl(host) {
        if (!host || !host.url || !Array.isArray(host.files)) return null;
        // Prefer GIF 2x/3x if present, else WEBP 2x/3x
        const byName = (n) => host.files.find(f => f.name === n);
        const candidates = ['3x.gif','2x.gif','3x.webp','2x.webp','1x.gif','1x.webp'];
        for (const name of candidates) {
          const f = byName(name);
          if (f) return `${host.url}/${f.name}`;
        }
        // fallback first file
        return `${host.url}/${host.files[0].name}`;
      }

      function renderEmotes() {
        emoteGrid.innerHTML = '';
        const items = emoteList.filter(e => !emoteFilter || (e.name && e.name.toLowerCase().includes(emoteFilter)));
        for (const e of items) {
          const url = pickEmoteUrl(e.host);
          if (!url) continue;
          const cell = document.createElement('div');
          cell.className = 'emote';
          const img = document.createElement('img');
          img.src = url;
          img.alt = e.name || '';
          img.title = e.name || '';
          img.draggable = true;
          img.addEventListener('dragstart', (ev) => {
            try { ev.dataTransfer.setData('application/json', JSON.stringify({ kind: 'catalog', src: url, type: 'image' })); } catch {}
          });
          img.addEventListener('click', () => addMedia(url, 'image'));
          cell.appendChild(img);
          emoteGrid.appendChild(cell);
        }
      }

      // Saved sets
      function loadSavedSets() {
        try { savedSets = JSON.parse(localStorage.getItem(ST_SAVED_KEY) || '[]'); } catch { savedSets = []; }
      }
      function saveSavedSets() {
        localStorage.setItem(ST_SAVED_KEY, JSON.stringify(savedSets.slice(0, 12)));
      }
      function addSavedSet(set) {
        if (!set || !set.id) return;
        if (!savedSets.some(s => s.id === set.id)) savedSets.unshift(set);
        else {
          // move to top
          savedSets = [set, ...savedSets.filter(s => s.id !== set.id)];
        }
        saveSavedSets();
        renderSavedSets();
      }
      function removeSavedSet(id) {
        savedSets = savedSets.filter(s => s.id !== id);
        saveSavedSets();
        renderSavedSets();
      }
      function renderSavedSets() {
        stSaved.innerHTML = '';
        for (const s of savedSets) {
          const chip = document.createElement('div');
          chip.className = 'st-chip';
          chip.title = s.id;
          chip.textContent = s.name || s.id;
          chip.addEventListener('click', () => { stSetId.value = s.id; stLoadBtn.click(); });
          const del = document.createElement('button');
          del.className = 'del';
          del.textContent = '‚úï';
          del.title = '–£–¥–∞–ª–∏—Ç—å —Å–µ—Ç';
          del.addEventListener('click', (e) => { e.stopPropagation(); removeSavedSet(s.id); });
          chip.appendChild(del);
          stSaved.appendChild(chip);
        }
      }

      

      function addMedia(src, type) {
        const id = String(Date.now()) + Math.random().toString(36).slice(2);
        const item = { id, type, src, x: 100, y: 100, w: 320, h: 240 };
        mediaItems.push(item);
        createOverlayElement(item);
        render();
        broadcastState();
        addToCatalog(src, type); // auto-save into catalog
      }

      function createOverlayElement(item) {
        const box = document.createElement('div');
        box.className = 'overlay-box';
        box.style.left = item.x + 'px';
        box.style.top = item.y + 'px';
        box.style.width = item.w + 'px';
        box.style.height = item.h + 'px';

        const el = (item.type === 'youtube') ? document.createElement('iframe') : document.createElement(item.type === 'image' ? 'img' : 'video');
        if (item.type === 'youtube') {
          el.src = withYouTubeAutoplay(item.src);
          el.allow = 'autoplay; encrypted-media';
          el.referrerPolicy = 'no-referrer-when-downgrade';
          el.frameBorder = '0';
        } else {
          el.src = item.src;
          if (item.type === 'video') { el.autoplay = true; el.loop = true; el.playsInline = true; el.muted = false; el.volume = 1.0; el.addEventListener('canplay', () => { try { el.play(); } catch {} }); }
        }
        el.className = 'overlay-item';
        el.style.width = '100%';
        el.style.height = '100%';
        el.draggable = false;
        box.appendChild(el);

        const handle = document.createElement('div');
        handle.className = 'resize';
        box.appendChild(handle);

        const close = document.createElement('button');
        close.className = 'close';
        close.textContent = '‚úï';
        close.title = '–£–¥–∞–ª–∏—Ç—å';
        close.addEventListener('click', (e) => {
          e.stopPropagation();
          removeMediaById(item.id);
        });
        box.appendChild(close);

        // Dragging
        let dragging = false; let dragOffset = {x:0,y:0};
        box.addEventListener('mousedown', (e) => {
          if (e.target === handle) return; // resizing handled below
          dragging = true;
          const rect = box.getBoundingClientRect();
          dragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        });
        // Resizing
        let resizing = false; let keepAspect = true; let aspect = null;
        handle.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          resizing = true;
          aspect = el.videoWidth && el.videoHeight ? (el.videoWidth / el.videoHeight) : (item.w / item.h);
        });

        window.addEventListener('mouseup', () => { if (dragging || resizing) { dragging = false; resizing = false; broadcastState(); } });
        window.addEventListener('mousemove', (e) => {
          const rect = wrap.getBoundingClientRect();
          if (dragging) {
            item.x = Math.max(0, Math.min(stage.width - item.w, (e.clientX - rect.left) * (stage.width / rect.width) - dragOffset.x));
            item.y = Math.max(0, Math.min(stage.height - item.h, (e.clientY - rect.top) * (stage.height / rect.height) - dragOffset.y));
            box.style.left = item.x + 'px';
            box.style.top = item.y + 'px';
          }
          if (resizing) {
            const newW = Math.max(40, (e.clientX - rect.left) * (stage.width / rect.width) - item.x);
            const newH = Math.max(40, (e.clientY - rect.top) * (stage.height / rect.height) - item.y);
            if (keepAspect) {
              const ratio = aspect || (item.w / item.h || 1);
              if (newW / newH > ratio) { item.w = Math.round(newH * ratio); item.h = Math.round(newH); }
              else { item.w = Math.round(newW); item.h = Math.round(newW / ratio); }
            } else {
              item.w = Math.round(newW); item.h = Math.round(newH);
            }
            box.style.width = item.w + 'px';
            box.style.height = item.h + 'px';
          }
        });

        wrap.appendChild(box);
        item._el = box;
      }

      function removeMediaById(id) {
        const idx = mediaItems.findIndex(m => m.id === id);
        if (idx !== -1) {
          const it = mediaItems[idx];
          if (it._el) it._el.remove();
          mediaItems.splice(idx, 1);
          render();
          broadcastState();
        }
      }

      function render() {
        // Canvas already contains brush strokes. Just ensure overlay positions are synced
        for (const item of mediaItems) {
          if (!item._el) continue;
          item._el.style.left = item.x + 'px';
          item._el.style.top = item.y + 'px';
          item._el.style.width = item.w + 'px';
          item._el.style.height = item.h + 'px';
        }
        
      }

      // Catalog logic
      function loadCatalog() {
        try { catalog = JSON.parse(localStorage.getItem(CATALOG_KEY) || '[]'); } catch { catalog = []; }
      }
      function saveCatalog() {
        localStorage.setItem(CATALOG_KEY, JSON.stringify(catalog));
      }
      function addToCatalog(src, type) {
        if (!catalog.some(c => c.src === src)) { catalog.unshift({ id: String(Date.now()), src, type }); saveCatalog(); renderCatalog(); }
      }
      function removeFromCatalog(id) {
        catalog = catalog.filter(c => c.id !== id);
        saveCatalog();
        renderCatalog();
      }
      function renderCatalog() {
        const grid = document.getElementById('catalogGrid');
        grid.innerHTML = '';
        for (const m of catalog) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          let el;
          if (m.type === 'youtube') {
            el = document.createElement('img');
            el.src = ytThumbFromEmbed(m.src);
          } else {
            el = document.createElement(m.type === 'video' ? 'video' : 'img');
            el.src = m.src;
            if (m.type === 'video') { el.muted = false; el.loop = true; el.autoplay = true; el.playsInline = true; }
          }
          el.title = '–ö–ª–∏–∫ ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –Ω–∞ —Å—Ü–µ–Ω—É. –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –Ω–∞ —Ö–æ–ª—Å—Ç ‚Äî –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞—Ç—å.';
          el.draggable = true;
          el.addEventListener('dragstart', (e) => {
            try { e.dataTransfer.setData('application/json', JSON.stringify({ kind: 'catalog', src: m.src, type: m.type })); } catch {}
          });
          el.addEventListener('click', () => addMedia(m.src, m.type));
          const del = document.createElement('button');
          del.className = 'del';
          del.textContent = '‚úï';
          del.title = '–£–¥–∞–ª–∏—Ç—å –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞';
          del.addEventListener('click', (e) => { e.stopPropagation(); removeFromCatalog(m.id); });
          cell.appendChild(el);
          cell.appendChild(del);
          grid.appendChild(cell);
        }
      }

      // Drag & drop into catalog
      const catalogBox = document.getElementById('catalog');
      catalogBox.addEventListener('dragover', (e) => { e.preventDefault(); catalogBox.classList.add('drop-active'); });
      catalogBox.addEventListener('dragleave', () => catalogBox.classList.remove('drop-active'));
      catalogBox.addEventListener('drop', (e) => {
        e.preventDefault(); catalogBox.classList.remove('drop-active');
        const text = e.dataTransfer.getData('text/uri-list') || e.dataTransfer.getData('text/plain');
        if (text) {
          const ytId = parseYouTube(text.trim());
          if (ytId) { const embed = ytToEmbed(ytId); addToCatalog(embed, 'youtube'); renderCatalog(); return; }
          // accept generic image/mp4 links
          if (/\.(png|gif)$/i.test(text)) { addToCatalog(text.trim(), 'image'); return; }
          if (/\.mp4$/i.test(text)) { addToCatalog(text.trim(), 'video'); return; }
        }
        const files = e.dataTransfer.files;
        for (const file of files) {
          if (!/image\/(png|gif)|video\/mp4/.test(file.type)) continue;
          const url = URL.createObjectURL(file);
          const type = file.type.startsWith('video') ? 'video' : 'image';
          addToCatalog(url, type);
        }
      });

      document.getElementById('clearCatalog').onclick = () => { if (confirm('–û—á–∏—Å—Ç–∏—Ç—å –∫–∞—Ç–∞–ª–æ–≥?')) { catalog = []; saveCatalog(); renderCatalog(); } };

      // Drag from catalog onto stage
      function clientToCanvas(clientX, clientY) {
        const rect = wrap.getBoundingClientRect();
        const x = (clientX - rect.left) * (stage.width / rect.width);
        const y = (clientY - rect.top) * (stage.height / rect.height);
        return { x, y };
      }
      wrap.addEventListener('dragover', (e) => { e.preventDefault(); wrap.classList.add('stage-drop'); });
      wrap.addEventListener('dragleave', () => { wrap.classList.remove('stage-drop'); });
      wrap.addEventListener('drop', (e) => {
        e.preventDefault(); wrap.classList.remove('stage-drop');
        const pos = clientToCanvas(e.clientX, e.clientY);
        // If dragging from catalog
        let json = null;
        try { json = JSON.parse(e.dataTransfer.getData('application/json') || 'null'); } catch {}
        if (json && json.kind === 'catalog' && json.src && json.type) {
          const id = String(Date.now()) + Math.random().toString(36).slice(2);
          const item = { id, type: json.type, src: json.src, x: Math.max(0, pos.x - 160), y: Math.max(0, pos.y - 120), w: 320, h: 240 };
          mediaItems.push(item);
          createOverlayElement(item);
          render();
          broadcastState();
          return;
        }
        // If a URL is dropped directly onto stage
        const text = e.dataTransfer.getData('text/uri-list') || e.dataTransfer.getData('text/plain');
        if (text) {
          const t = text.trim();
          const ytId = parseYouTube(t);
          if (ytId) {
            const embed = ytToEmbed(ytId);
            const id = String(Date.now()) + Math.random().toString(36).slice(2);
            const item = { id, type: 'youtube', src: embed, x: Math.max(0, pos.x - 160), y: Math.max(0, pos.y - 120), w: 320, h: 240 };
            mediaItems.push(item);
            createOverlayElement(item);
            addToCatalog(embed, 'youtube');
            render(); broadcastState();
            return;
          }
          if (/\.(png|gif)$/i.test(t) || /data:image\//.test(t)) {
            const id = String(Date.now()) + Math.random().toString(36).slice(2);
            const item = { id, type: 'image', src: t, x: Math.max(0, pos.x - 160), y: Math.max(0, pos.y - 120), w: 320, h: 240 };
            mediaItems.push(item); createOverlayElement(item); addToCatalog(t, 'image'); render(); broadcastState(); return;
          }
          if (/\.mp4$/i.test(t)) {
            const id = String(Date.now()) + Math.random().toString(36).slice(2);
            const item = { id, type: 'video', src: t, x: Math.max(0, pos.x - 160), y: Math.max(0, pos.y - 120), w: 320, h: 240 };
            mediaItems.push(item); createOverlayElement(item); addToCatalog(t, 'video'); render(); broadcastState(); return;
          }
        }
        // Or files dropped directly onto the stage
        const files = e.dataTransfer.files;
        if (files && files.length) {
          for (const file of files) {
            if (!/image\/(png|gif)|video\/mp4/.test(file.type)) continue;
            const url = URL.createObjectURL(file);
            const type = file.type.startsWith('video') ? 'video' : 'image';
            const id = String(Date.now()) + Math.random().toString(36).slice(2);
            const item = { id, type, src: url, x: Math.max(0, pos.x - 160), y: Math.max(0, pos.y - 120), w: 320, h: 240 };
            mediaItems.push(item);
            createOverlayElement(item);
            addToCatalog(url, type);
          }
          render();
          broadcastState();
        }
      });

      function getState() {
        return {
          size: { w: stage.width, h: stage.height },
          bg: 'green',
          drawing: stage.toDataURL('image/png'),
          media: mediaItems.map(({ id, type, src, x, y, w, h }) => ({ id, type, src, x, y, w, h })),
        };
      }

      async function broadcastState() {
        const payload = { type: 'state', payload: getState() };
        try {
          await fetch(serverUrl + '/broadcast', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        } catch (e) {
          console.warn('Broadcast failed', e);
        }
      }

      sendStateBtn.onclick = broadcastState;
      // Initial push
      setTimeout(broadcastState, 300);

      // Init catalog
      loadCatalog();
      renderCatalog();
      // Init saved 7TV sets
      loadSavedSets();
      renderSavedSets();

      // YouTube helpers
      function parseYouTube(url) {
        try {
          const u = new URL(url);
          if (u.hostname.includes('youtube.com')) {
            const id = u.searchParams.get('v');
            return id || null;
          }
          if (u.hostname === 'youtu.be') {
            return u.pathname.slice(1) || null;
          }
          return null;
        } catch { return null; }
      }
      function ytToEmbed(id) { return `https://www.youtube.com/embed/${id}`; }
      function withYouTubeAutoplay(embedUrl) {
        try {
          const u = new URL(embedUrl);
          u.searchParams.set('autoplay', '1');
          u.searchParams.set('mute', '0');
          u.searchParams.set('controls', '0');
          u.searchParams.set('rel', '0');
          return u.toString();
        } catch { return embedUrl; }
      }
      function ytThumbFromEmbed(embedUrl) {
        try {
          const u = new URL(embedUrl);
          const id = u.pathname.split('/').pop();
          return `https://img.youtube.com/vi/${id}/hqdefault.jpg`;
        } catch { return ''; }
      }

      
    </script>
  </body>
  </html>


